{"ast":null,"code":"import { defineComponent, inject, ref, provide, computed, unref, onMounted, watch, onBeforeUnmount, openBlock, createElementBlock, normalizeStyle, normalizeClass, createVNode, withCtx, renderSlot } from 'vue';\nimport { NOOP } from '@vue/shared';\nimport { isNil } from 'lodash-unified';\nimport { createPopper } from '@popperjs/core';\nimport '../../focus-trap/index.mjs';\nimport '../../../hooks/index.mjs';\nimport '../../../tokens/index.mjs';\nimport '../../../utils/index.mjs';\nimport { popperContentProps, popperContentEmits } from './content.mjs';\nimport { unwrapMeasurableEl, buildPopperOptions } from './utils.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { POPPER_INJECTION_KEY, POPPER_CONTENT_INJECTION_KEY } from '../../../tokens/popper.mjs';\nimport { formItemContextKey } from '../../../tokens/form.mjs';\nimport { useZIndex } from '../../../hooks/use-z-index/index.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { isElement } from '../../../utils/types.mjs';\nimport ElFocusTrap from '../../focus-trap/src/focus-trap.mjs';\n\nconst __default__ = defineComponent({\n  name: \"ElPopperContent\"\n});\n\nconst _sfc_main = /* @__PURE__ */defineComponent({ ...__default__,\n  props: popperContentProps,\n  emits: popperContentEmits,\n\n  setup(__props, {\n    expose,\n    emit\n  }) {\n    const props = __props;\n    const {\n      popperInstanceRef,\n      contentRef,\n      triggerRef,\n      role\n    } = inject(POPPER_INJECTION_KEY, void 0);\n    const formItemContext = inject(formItemContextKey, void 0);\n    const {\n      nextZIndex\n    } = useZIndex();\n    const ns = useNamespace(\"popper\");\n    const popperContentRef = ref();\n    const focusStartRef = ref(\"first\");\n    const arrowRef = ref();\n    const arrowOffset = ref();\n    provide(POPPER_CONTENT_INJECTION_KEY, {\n      arrowRef,\n      arrowOffset\n    });\n\n    if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {\n      provide(formItemContextKey, { ...formItemContext,\n        addInputId: NOOP,\n        removeInputId: NOOP\n      });\n    }\n\n    const contentZIndex = ref(props.zIndex || nextZIndex());\n    const trapped = ref(false);\n    let triggerTargetAriaStopWatch = void 0;\n    const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));\n    const contentStyle = computed(() => [{\n      zIndex: unref(contentZIndex)\n    }, props.popperStyle]);\n    const contentClass = computed(() => [ns.b(), ns.is(\"pure\", props.pure), ns.is(props.effect), props.popperClass]);\n    const ariaModal = computed(() => {\n      return role && role.value === \"dialog\" ? \"false\" : void 0;\n    });\n\n    const createPopperInstance = ({\n      referenceEl,\n      popperContentEl,\n      arrowEl\n    }) => {\n      const options = buildPopperOptions(props, {\n        arrowEl,\n        arrowOffset: unref(arrowOffset)\n      });\n      return createPopper(referenceEl, popperContentEl, options);\n    };\n\n    const updatePopper = (shouldUpdateZIndex = true) => {\n      var _a;\n\n      (_a = unref(popperInstanceRef)) == null ? void 0 : _a.update();\n      shouldUpdateZIndex && (contentZIndex.value = props.zIndex || nextZIndex());\n    };\n\n    const togglePopperAlive = () => {\n      var _a, _b;\n\n      const monitorable = {\n        name: \"eventListeners\",\n        enabled: props.visible\n      };\n      (_b = (_a = unref(popperInstanceRef)) == null ? void 0 : _a.setOptions) == null ? void 0 : _b.call(_a, options => ({ ...options,\n        modifiers: [...(options.modifiers || []), monitorable]\n      }));\n      updatePopper(false);\n\n      if (props.visible && props.focusOnShow) {\n        trapped.value = true;\n      } else if (props.visible === false) {\n        trapped.value = false;\n      }\n    };\n\n    const onFocusAfterTrapped = () => {\n      emit(\"focus\");\n    };\n\n    const onFocusAfterReleased = event => {\n      var _a;\n\n      if (((_a = event.detail) == null ? void 0 : _a.focusReason) !== \"pointer\") {\n        focusStartRef.value = \"first\";\n        emit(\"blur\");\n      }\n    };\n\n    const onFocusInTrap = event => {\n      if (props.visible && !trapped.value) {\n        if (event.target) {\n          focusStartRef.value = event.target;\n        }\n\n        trapped.value = true;\n      }\n    };\n\n    const onFocusoutPrevented = event => {\n      if (!props.trapping) {\n        if (event.detail.focusReason === \"pointer\") {\n          event.preventDefault();\n        }\n\n        trapped.value = false;\n      }\n    };\n\n    const onReleaseRequested = () => {\n      trapped.value = false;\n      emit(\"close\");\n    };\n\n    onMounted(() => {\n      let updateHandle;\n      watch(computedReference, referenceEl => {\n        var _a;\n\n        updateHandle == null ? void 0 : updateHandle();\n        const popperInstance = unref(popperInstanceRef);\n        (_a = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a.call(popperInstance);\n\n        if (referenceEl) {\n          const popperContentEl = unref(popperContentRef);\n          contentRef.value = popperContentEl;\n          popperInstanceRef.value = createPopperInstance({\n            referenceEl,\n            popperContentEl,\n            arrowEl: unref(arrowRef)\n          });\n          updateHandle = watch(() => referenceEl.getBoundingClientRect(), () => updatePopper(), {\n            immediate: true\n          });\n        } else {\n          popperInstanceRef.value = void 0;\n        }\n      }, {\n        immediate: true\n      });\n      watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {\n        triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();\n        triggerTargetAriaStopWatch = void 0;\n        const el = unref(triggerTargetEl || popperContentRef.value);\n        const prevEl = unref(prevTriggerTargetEl || popperContentRef.value);\n\n        if (isElement(el)) {\n          triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], watches => {\n            ;\n            [\"role\", \"aria-label\", \"aria-modal\", \"id\"].forEach((key, idx) => {\n              isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);\n            });\n          }, {\n            immediate: true\n          });\n        }\n\n        if (prevEl !== el && isElement(prevEl)) {\n          ;\n          [\"role\", \"aria-label\", \"aria-modal\", \"id\"].forEach(key => {\n            prevEl.removeAttribute(key);\n          });\n        }\n      }, {\n        immediate: true\n      });\n      watch(() => props.visible, togglePopperAlive, {\n        immediate: true\n      });\n      watch(() => buildPopperOptions(props, {\n        arrowEl: unref(arrowRef),\n        arrowOffset: unref(arrowOffset)\n      }), option => {\n        var _a;\n\n        return (_a = popperInstanceRef.value) == null ? void 0 : _a.setOptions(option);\n      });\n    });\n    onBeforeUnmount(() => {\n      triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();\n      triggerTargetAriaStopWatch = void 0;\n    });\n    expose({\n      popperContentRef,\n      popperInstanceRef,\n      updatePopper,\n      contentStyle\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"popperContentRef\",\n        ref: popperContentRef,\n        style: normalizeStyle(unref(contentStyle)),\n        class: normalizeClass(unref(contentClass)),\n        tabindex: \"-1\",\n        onMouseenter: _cache[0] || (_cache[0] = e => _ctx.$emit(\"mouseenter\", e)),\n        onMouseleave: _cache[1] || (_cache[1] = e => _ctx.$emit(\"mouseleave\", e))\n      }, [createVNode(unref(ElFocusTrap), {\n        trapped: trapped.value,\n        \"trap-on-focus-in\": true,\n        \"focus-trap-el\": popperContentRef.value,\n        \"focus-start-el\": focusStartRef.value,\n        onFocusAfterTrapped,\n        onFocusAfterReleased,\n        onFocusin: onFocusInTrap,\n        onFocusoutPrevented,\n        onReleaseRequested\n      }, {\n        default: withCtx(() => [renderSlot(_ctx.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"trapped\", \"focus-trap-el\", \"focus-start-el\"])], 38);\n    };\n  }\n\n});\n\nvar ElPopperContent = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue\"]]);\n\nexport { ElPopperContent as default };","map":{"version":3,"mappings":"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","names":["name","popperInstanceRef","contentRef","triggerRef","role","inject","POPPER_INJECTION_KEY","nextZIndex","useZIndex","useNamespace","popperContentRef","ref","arrowRef","arrowOffset","provide","POPPER_CONTENT_INJECTION_KEY","formItemContext","addInputId","removeInputId","formItemContextKey","contentZIndex","props","triggerTargetAriaStopWatch","computed","unwrapMeasurableEl","referenceEl","unref","contentStyle","zIndex","ns","b","pure","is","effect","value","createPopperInstance","popperContentEl","arrowEl","buildPopperOptions","options","shouldUpdateZIndex","_a","_b","monitorable","enabled","modifiers","updatePopper","trapped","emit","focusStartRef","focusReason","event","onMounted","watch","updateHandle","popperInstance","immediate","isNil","el","key","prevEl","forEach","removeAttribute","option","onBeforeUnmount"],"sources":["../../../../../../packages/components/popper/src/content.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"popperContentRef\"\n    :style=\"contentStyle\"\n    :class=\"contentClass\"\n    tabindex=\"-1\"\n    @mouseenter=\"(e) => $emit('mouseenter', e)\"\n    @mouseleave=\"(e) => $emit('mouseleave', e)\"\n  >\n    <el-focus-trap\n      :trapped=\"trapped\"\n      :trap-on-focus-in=\"true\"\n      :focus-trap-el=\"popperContentRef\"\n      :focus-start-el=\"focusStartRef\"\n      @focus-after-trapped=\"onFocusAfterTrapped\"\n      @focus-after-released=\"onFocusAfterReleased\"\n      @focusin=\"onFocusInTrap\"\n      @focusout-prevented=\"onFocusoutPrevented\"\n      @release-requested=\"onReleaseRequested\"\n    >\n      <slot />\n    </el-focus-trap>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  inject,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { NOOP } from '@vue/shared'\nimport { isNil } from 'lodash-unified'\nimport { createPopper } from '@popperjs/core'\nimport ElFocusTrap from '@element-plus/components/focus-trap'\nimport { useNamespace, useZIndex } from '@element-plus/hooks'\nimport {\n  POPPER_CONTENT_INJECTION_KEY,\n  POPPER_INJECTION_KEY,\n  formItemContextKey,\n} from '@element-plus/tokens'\nimport { isElement } from '@element-plus/utils'\nimport { popperContentEmits, popperContentProps } from './content'\nimport { buildPopperOptions, unwrapMeasurableEl } from './utils'\n\nimport type { WatchStopHandle } from 'vue'\nimport type { CreatePopperInstanceParams } from './content'\n\ndefineOptions({\n  name: 'ElPopperContent',\n})\n\nconst emit = defineEmits(popperContentEmits)\n\nconst props = defineProps(popperContentProps)\n\nconst { popperInstanceRef, contentRef, triggerRef, role } = inject(\n  POPPER_INJECTION_KEY,\n  undefined\n)!\nconst formItemContext = inject(formItemContextKey, undefined)\nconst { nextZIndex } = useZIndex()\nconst ns = useNamespace('popper')\nconst popperContentRef = ref<HTMLElement>()\nconst focusStartRef = ref<'container' | 'first' | HTMLElement>('first')\nconst arrowRef = ref<HTMLElement>()\nconst arrowOffset = ref<number>()\nprovide(POPPER_CONTENT_INJECTION_KEY, {\n  arrowRef,\n  arrowOffset,\n})\n\nif (\n  formItemContext &&\n  (formItemContext.addInputId || formItemContext.removeInputId)\n) {\n  // disallow auto-id from inside popper content\n  provide(formItemContextKey, {\n    ...formItemContext,\n    addInputId: NOOP,\n    removeInputId: NOOP,\n  })\n}\n\nconst contentZIndex = ref<number>(props.zIndex || nextZIndex())\nconst trapped = ref<boolean>(false)\n\nlet triggerTargetAriaStopWatch: WatchStopHandle | undefined = undefined\n\nconst computedReference = computed(\n  () => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef)\n)\n\nconst contentStyle = computed(\n  () => [{ zIndex: unref(contentZIndex) }, props.popperStyle] as any\n)\n\nconst contentClass = computed(() => [\n  ns.b(),\n  ns.is('pure', props.pure),\n  ns.is(props.effect),\n  props.popperClass,\n])\n\nconst ariaModal = computed<string | undefined>(() => {\n  return role && role.value === 'dialog' ? 'false' : undefined\n})\n\nconst createPopperInstance = ({\n  referenceEl,\n  popperContentEl,\n  arrowEl,\n}: CreatePopperInstanceParams) => {\n  const options = buildPopperOptions(props, {\n    arrowEl,\n    arrowOffset: unref(arrowOffset),\n  })\n\n  return createPopper(referenceEl, popperContentEl, options)\n}\n\nconst updatePopper = (shouldUpdateZIndex = true) => {\n  unref(popperInstanceRef)?.update()\n  shouldUpdateZIndex && (contentZIndex.value = props.zIndex || nextZIndex())\n}\n\nconst togglePopperAlive = () => {\n  const monitorable = { name: 'eventListeners', enabled: props.visible }\n  unref(popperInstanceRef)?.setOptions?.((options) => ({\n    ...options,\n    modifiers: [...(options.modifiers || []), monitorable],\n  }))\n  updatePopper(false)\n  if (props.visible && props.focusOnShow) {\n    trapped.value = true\n  } else if (props.visible === false) {\n    trapped.value = false\n  }\n}\n\nconst onFocusAfterTrapped = () => {\n  emit('focus')\n}\n\nconst onFocusAfterReleased = (event: CustomEvent) => {\n  if (event.detail?.focusReason !== 'pointer') {\n    focusStartRef.value = 'first'\n    emit('blur')\n  }\n}\n\nconst onFocusInTrap = (event: FocusEvent) => {\n  if (props.visible && !trapped.value) {\n    if (event.target) {\n      focusStartRef.value = event.target as typeof focusStartRef.value\n    }\n    trapped.value = true\n  }\n}\n\nconst onFocusoutPrevented = (event: CustomEvent) => {\n  if (!props.trapping) {\n    if (event.detail.focusReason === 'pointer') {\n      event.preventDefault()\n    }\n    trapped.value = false\n  }\n}\n\nconst onReleaseRequested = () => {\n  trapped.value = false\n  emit('close')\n}\n\nonMounted(() => {\n  let updateHandle: WatchStopHandle\n  watch(\n    computedReference,\n    (referenceEl) => {\n      updateHandle?.()\n      const popperInstance = unref(popperInstanceRef)\n      popperInstance?.destroy?.()\n      if (referenceEl) {\n        const popperContentEl = unref(popperContentRef)!\n        contentRef.value = popperContentEl\n\n        popperInstanceRef.value = createPopperInstance({\n          referenceEl,\n          popperContentEl,\n          arrowEl: unref(arrowRef),\n        })\n\n        updateHandle = watch(\n          () => referenceEl.getBoundingClientRect(),\n          () => updatePopper(),\n          {\n            immediate: true,\n          }\n        )\n      } else {\n        popperInstanceRef.value = undefined\n      }\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  watch(\n    () => props.triggerTargetEl,\n    (triggerTargetEl, prevTriggerTargetEl) => {\n      triggerTargetAriaStopWatch?.()\n      triggerTargetAriaStopWatch = undefined\n\n      const el = unref(triggerTargetEl || popperContentRef.value)\n      const prevEl = unref(prevTriggerTargetEl || popperContentRef.value)\n\n      if (isElement(el)) {\n        triggerTargetAriaStopWatch = watch(\n          [role, () => props.ariaLabel, ariaModal, () => props.id],\n          (watches) => {\n            ;['role', 'aria-label', 'aria-modal', 'id'].forEach((key, idx) => {\n              isNil(watches[idx])\n                ? el.removeAttribute(key)\n                : el.setAttribute(key, watches[idx]!)\n            })\n          },\n          { immediate: true }\n        )\n      }\n      if (prevEl !== el && isElement(prevEl)) {\n        ;['role', 'aria-label', 'aria-modal', 'id'].forEach((key) => {\n          prevEl.removeAttribute(key)\n        })\n      }\n    },\n    { immediate: true }\n  )\n\n  watch(() => props.visible, togglePopperAlive, { immediate: true })\n\n  watch(\n    () =>\n      buildPopperOptions(props, {\n        arrowEl: unref(arrowRef),\n        arrowOffset: unref(arrowOffset),\n      }),\n    (option) => popperInstanceRef.value?.setOptions(option)\n  )\n})\n\nonBeforeUnmount(() => {\n  triggerTargetAriaStopWatch?.()\n  triggerTargetAriaStopWatch = undefined\n})\n\ndefineExpose({\n  /**\n   * @description popper content element\n   */\n  popperContentRef,\n  /**\n   * @description popperjs instance\n   */\n  popperInstanceRef,\n  /**\n   * @description method for updating popper\n   */\n  updatePopper,\n\n  /**\n   * @description content style\n   */\n  contentStyle,\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}