{"ast":null,"code":"import { defineComponent, shallowRef, ref, computed, watch, onMounted, watchEffect, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, createElementVNode, renderSlot } from 'vue';\nimport { useWindowSize, useElementBounding, useEventListener } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { affixProps, affixEmits } from './affix.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { getScrollContainer } from '../../../utils/dom/scroll.mjs';\nconst COMPONENT_NAME = \"ElAffix\";\n\nconst __default__ = defineComponent({\n  name: COMPONENT_NAME\n});\n\nconst _sfc_main = /* @__PURE__ */defineComponent({ ...__default__,\n  props: affixProps,\n  emits: affixEmits,\n\n  setup(__props, {\n    expose,\n    emit\n  }) {\n    const props = __props;\n    const ns = useNamespace(\"affix\");\n    const target = shallowRef();\n    const root = shallowRef();\n    const scrollContainer = shallowRef();\n    const {\n      height: windowHeight\n    } = useWindowSize();\n    const {\n      height: rootHeight,\n      width: rootWidth,\n      top: rootTop,\n      bottom: rootBottom,\n      update: updateRoot\n    } = useElementBounding(root, {\n      windowScroll: false\n    });\n    const targetRect = useElementBounding(target);\n    const fixed = ref(false);\n    const scrollTop = ref(0);\n    const transform = ref(0);\n    const rootStyle = computed(() => {\n      return {\n        height: fixed.value ? `${rootHeight.value}px` : \"\",\n        width: fixed.value ? `${rootWidth.value}px` : \"\"\n      };\n    });\n    const affixStyle = computed(() => {\n      if (!fixed.value) return {};\n      const offset = props.offset ? `${props.offset}px` : 0;\n      return {\n        height: `${rootHeight.value}px`,\n        width: `${rootWidth.value}px`,\n        top: props.position === \"top\" ? offset : \"\",\n        bottom: props.position === \"bottom\" ? offset : \"\",\n        transform: transform.value ? `translateY(${transform.value}px)` : \"\",\n        zIndex: props.zIndex\n      };\n    });\n\n    const update = () => {\n      if (!scrollContainer.value) return;\n      scrollTop.value = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop || 0;\n\n      if (props.position === \"top\") {\n        if (props.target) {\n          const difference = targetRect.bottom.value - props.offset - rootHeight.value;\n          fixed.value = props.offset > rootTop.value && targetRect.bottom.value > 0;\n          transform.value = difference < 0 ? difference : 0;\n        } else {\n          fixed.value = props.offset > rootTop.value;\n        }\n      } else if (props.target) {\n        const difference = windowHeight.value - targetRect.top.value - props.offset - rootHeight.value;\n        fixed.value = windowHeight.value - props.offset < rootBottom.value && windowHeight.value > targetRect.top.value;\n        transform.value = difference < 0 ? -difference : 0;\n      } else {\n        fixed.value = windowHeight.value - props.offset < rootBottom.value;\n      }\n    };\n\n    const handleScroll = () => {\n      updateRoot();\n      emit(\"scroll\", {\n        scrollTop: scrollTop.value,\n        fixed: fixed.value\n      });\n    };\n\n    watch(fixed, val => emit(\"change\", val));\n    onMounted(() => {\n      var _a;\n\n      if (props.target) {\n        target.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;\n        if (!target.value) throwError(COMPONENT_NAME, `Target is not existed: ${props.target}`);\n      } else {\n        target.value = document.documentElement;\n      }\n\n      scrollContainer.value = getScrollContainer(root.value, true);\n      updateRoot();\n    });\n    useEventListener(scrollContainer, \"scroll\", handleScroll);\n    watchEffect(update);\n    expose({\n      update,\n      updateRoot\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"root\",\n        ref: root,\n        class: normalizeClass(unref(ns).b()),\n        style: normalizeStyle(unref(rootStyle))\n      }, [createElementVNode(\"div\", {\n        class: normalizeClass({\n          [unref(ns).m(\"fixed\")]: fixed.value\n        }),\n        style: normalizeStyle(unref(affixStyle))\n      }, [renderSlot(_ctx.$slots, \"default\")], 6)], 6);\n    };\n  }\n\n});\n\nvar Affix = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue\"]]);\n\nexport { Affix as default };","map":{"version":3,"mappings":"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","names":["name","useNamespace","target","shallowRef","root","scrollContainer","height","useWindowSize","width","top","bottom","update","useElementBounding","windowScroll","ref","computed","value","rootHeight","rootWidth","fixed","offset","props","position","transform","zIndex","scrollTop","Window","document","documentElement","difference","targetRect","rootTop","windowHeight","rootBottom","handleScroll","updateRoot","emit","watch","val","onMounted","_a","throwError","useEventListener","watchEffect","expose"],"sources":["../../../../../../packages/components/affix/src/affix.vue"],"sourcesContent":["<template>\n  <div ref=\"root\" :class=\"ns.b()\" :style=\"rootStyle\">\n    <div :class=\"{ [ns.m('fixed')]: fixed }\" :style=\"affixStyle\">\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, onMounted, ref, shallowRef, watch, watchEffect } from 'vue'\nimport {\n  useElementBounding,\n  useEventListener,\n  useWindowSize,\n} from '@vueuse/core'\nimport { getScrollContainer, throwError } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { affixEmits, affixProps } from './affix'\nimport type { CSSProperties } from 'vue'\n\nconst COMPONENT_NAME = 'ElAffix'\ndefineOptions({\n  name: COMPONENT_NAME,\n})\n\nconst props = defineProps(affixProps)\nconst emit = defineEmits(affixEmits)\n\nconst ns = useNamespace('affix')\n\nconst target = shallowRef<HTMLElement>()\nconst root = shallowRef<HTMLDivElement>()\nconst scrollContainer = shallowRef<HTMLElement | Window>()\nconst { height: windowHeight } = useWindowSize()\nconst {\n  height: rootHeight,\n  width: rootWidth,\n  top: rootTop,\n  bottom: rootBottom,\n  update: updateRoot,\n} = useElementBounding(root, { windowScroll: false })\nconst targetRect = useElementBounding(target)\n\nconst fixed = ref(false)\nconst scrollTop = ref(0)\nconst transform = ref(0)\n\nconst rootStyle = computed<CSSProperties>(() => {\n  return {\n    height: fixed.value ? `${rootHeight.value}px` : '',\n    width: fixed.value ? `${rootWidth.value}px` : '',\n  }\n})\n\nconst affixStyle = computed<CSSProperties>(() => {\n  if (!fixed.value) return {}\n\n  const offset = props.offset ? `${props.offset}px` : 0\n  return {\n    height: `${rootHeight.value}px`,\n    width: `${rootWidth.value}px`,\n    top: props.position === 'top' ? offset : '',\n    bottom: props.position === 'bottom' ? offset : '',\n    transform: transform.value ? `translateY(${transform.value}px)` : '',\n    zIndex: props.zIndex,\n  }\n})\n\nconst update = () => {\n  if (!scrollContainer.value) return\n\n  scrollTop.value =\n    scrollContainer.value instanceof Window\n      ? document.documentElement.scrollTop\n      : scrollContainer.value.scrollTop || 0\n\n  if (props.position === 'top') {\n    if (props.target) {\n      const difference =\n        targetRect.bottom.value - props.offset - rootHeight.value\n      fixed.value = props.offset > rootTop.value && targetRect.bottom.value > 0\n      transform.value = difference < 0 ? difference : 0\n    } else {\n      fixed.value = props.offset > rootTop.value\n    }\n  } else if (props.target) {\n    const difference =\n      windowHeight.value -\n      targetRect.top.value -\n      props.offset -\n      rootHeight.value\n    fixed.value =\n      windowHeight.value - props.offset < rootBottom.value &&\n      windowHeight.value > targetRect.top.value\n    transform.value = difference < 0 ? -difference : 0\n  } else {\n    fixed.value = windowHeight.value - props.offset < rootBottom.value\n  }\n}\n\nconst handleScroll = () => {\n  updateRoot()\n  emit('scroll', {\n    scrollTop: scrollTop.value,\n    fixed: fixed.value,\n  })\n}\n\nwatch(fixed, (val) => emit('change', val))\n\nonMounted(() => {\n  if (props.target) {\n    target.value =\n      document.querySelector<HTMLElement>(props.target) ?? undefined\n    if (!target.value)\n      throwError(COMPONENT_NAME, `Target is not existed: ${props.target}`)\n  } else {\n    target.value = document.documentElement\n  }\n  scrollContainer.value = getScrollContainer(root.value!, true)\n  updateRoot()\n})\n\nuseEventListener(scrollContainer, 'scroll', handleScroll)\nwatchEffect(update)\n\ndefineExpose({\n  /** @description update affix status */\n  update,\n  /** @description update rootRect info */\n  updateRoot,\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}