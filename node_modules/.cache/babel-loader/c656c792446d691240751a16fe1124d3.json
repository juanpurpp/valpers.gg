{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, useSlots, inject, ref, computed, nextTick, watch, reactive, toRefs, provide, onMounted, onBeforeUnmount, openBlock, createElementBlock, normalizeClass, unref, createVNode, withCtx, createBlock, resolveDynamicComponent, normalizeStyle, renderSlot, createTextVNode, toDisplayString, createCommentVNode, createElementVNode, Transition } from 'vue';\nimport AsyncValidator from 'async-validator';\nimport { castArray, clone } from 'lodash-unified';\nimport { refDebounced, isBoolean } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { formItemProps } from './form-item.mjs';\nimport FormLabelWrap from './form-label-wrap.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { formContextKey, formItemContextKey } from '../../../tokens/form.mjs';\nimport { useSize } from '../../../hooks/use-common-props/index.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { useId } from '../../../hooks/use-id/index.mjs';\nimport { addUnit } from '../../../utils/dom/style.mjs';\nimport { isString, isFunction } from '@vue/shared';\nimport { getProp } from '../../../utils/objects.mjs';\nconst _hoisted_1 = [\"role\", \"aria-labelledby\"];\n\nconst __default__ = defineComponent({\n  name: \"ElFormItem\"\n});\n\nconst _sfc_main = /* @__PURE__ */defineComponent({ ...__default__,\n  props: formItemProps,\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const slots = useSlots();\n    const formContext = inject(formContextKey, void 0);\n    const parentFormItemContext = inject(formItemContextKey, void 0);\n\n    const _size = useSize(void 0, {\n      formItem: false\n    });\n\n    const ns = useNamespace(\"form-item\");\n    const labelId = useId().value;\n    const inputIds = ref([]);\n    const validateState = ref(\"\");\n    const validateStateDebounced = refDebounced(validateState, 100);\n    const validateMessage = ref(\"\");\n    const formItemRef = ref();\n    let initialValue = void 0;\n    let isResettingField = false;\n    const labelStyle = computed(() => {\n      if ((formContext == null ? void 0 : formContext.labelPosition) === \"top\") {\n        return {};\n      }\n\n      const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || \"\");\n      if (labelWidth) return {\n        width: labelWidth\n      };\n      return {};\n    });\n    const contentStyle = computed(() => {\n      if ((formContext == null ? void 0 : formContext.labelPosition) === \"top\" || (formContext == null ? void 0 : formContext.inline)) {\n        return {};\n      }\n\n      if (!props.label && !props.labelWidth && isNested) {\n        return {};\n      }\n\n      const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || \"\");\n\n      if (!props.label && !slots.label) {\n        return {\n          marginLeft: labelWidth\n        };\n      }\n\n      return {};\n    });\n    const formItemClasses = computed(() => [ns.b(), ns.m(_size.value), ns.is(\"error\", validateState.value === \"error\"), ns.is(\"validating\", validateState.value === \"validating\"), ns.is(\"success\", validateState.value === \"success\"), ns.is(\"required\", isRequired.value || props.required), ns.is(\"no-asterisk\", formContext == null ? void 0 : formContext.hideRequiredAsterisk), (formContext == null ? void 0 : formContext.requireAsteriskPosition) === \"right\" ? \"asterisk-right\" : \"asterisk-left\", {\n      [ns.m(\"feedback\")]: formContext == null ? void 0 : formContext.statusIcon\n    }]);\n\n    const _inlineMessage = computed(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);\n\n    const validateClasses = computed(() => [ns.e(\"error\"), {\n      [ns.em(\"error\", \"inline\")]: _inlineMessage.value\n    }]);\n    const propString = computed(() => {\n      if (!props.prop) return \"\";\n      return isString(props.prop) ? props.prop : props.prop.join(\".\");\n    });\n    const hasLabel = computed(() => {\n      return !!(props.label || slots.label);\n    });\n    const labelFor = computed(() => {\n      return props.for || inputIds.value.length === 1 ? inputIds.value[0] : void 0;\n    });\n    const isGroup = computed(() => {\n      return !labelFor.value && hasLabel.value;\n    });\n    const isNested = !!parentFormItemContext;\n    const fieldValue = computed(() => {\n      const model = formContext == null ? void 0 : formContext.model;\n\n      if (!model || !props.prop) {\n        return;\n      }\n\n      return getProp(model, props.prop).value;\n    });\n    const normalizedRules = computed(() => {\n      const {\n        required\n      } = props;\n      const rules = [];\n\n      if (props.rules) {\n        rules.push(...castArray(props.rules));\n      }\n\n      const formRules = formContext == null ? void 0 : formContext.rules;\n\n      if (formRules && props.prop) {\n        const _rules = getProp(formRules, props.prop).value;\n\n        if (_rules) {\n          rules.push(...castArray(_rules));\n        }\n      }\n\n      if (required !== void 0) {\n        const requiredRules = rules.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes(\"required\"));\n\n        if (requiredRules.length > 0) {\n          for (const [rule, i] of requiredRules) {\n            if (rule.required === required) continue;\n            rules[i] = { ...rule,\n              required\n            };\n          }\n        } else {\n          rules.push({\n            required\n          });\n        }\n      }\n\n      return rules;\n    });\n    const validateEnabled = computed(() => normalizedRules.value.length > 0);\n\n    const getFilteredRule = trigger => {\n      const rules = normalizedRules.value;\n      return rules.filter(rule => {\n        if (!rule.trigger || !trigger) return true;\n\n        if (Array.isArray(rule.trigger)) {\n          return rule.trigger.includes(trigger);\n        } else {\n          return rule.trigger === trigger;\n        }\n      }).map(({\n        trigger: trigger2,\n        ...rule\n      }) => rule);\n    };\n\n    const isRequired = computed(() => normalizedRules.value.some(rule => rule.required));\n    const shouldShowError = computed(() => {\n      var _a;\n\n      return validateStateDebounced.value === \"error\" && props.showMessage && ((_a = formContext == null ? void 0 : formContext.showMessage) != null ? _a : true);\n    });\n    const currentLabel = computed(() => `${props.label || \"\"}${(formContext == null ? void 0 : formContext.labelSuffix) || \"\"}`);\n\n    const setValidationState = state => {\n      validateState.value = state;\n    };\n\n    const onValidationFailed = error => {\n      var _a, _b;\n\n      const {\n        errors,\n        fields\n      } = error;\n\n      if (!errors || !fields) {\n        console.error(error);\n      }\n\n      setValidationState(\"error\");\n      validateMessage.value = errors ? (_b = (_a = errors == null ? void 0 : errors[0]) == null ? void 0 : _a.message) != null ? _b : `${props.prop} is required` : \"\";\n      formContext == null ? void 0 : formContext.emit(\"validate\", props.prop, false, validateMessage.value);\n    };\n\n    const onValidationSucceeded = () => {\n      setValidationState(\"success\");\n      formContext == null ? void 0 : formContext.emit(\"validate\", props.prop, true, \"\");\n    };\n\n    const doValidate = async rules => {\n      const modelName = propString.value;\n      const validator = new AsyncValidator({\n        [modelName]: rules\n      });\n      return validator.validate({\n        [modelName]: fieldValue.value\n      }, {\n        firstFields: true\n      }).then(() => {\n        onValidationSucceeded();\n        return true;\n      }).catch(err => {\n        onValidationFailed(err);\n        return Promise.reject(err);\n      });\n    };\n\n    const validate = async (trigger, callback) => {\n      if (isResettingField || !props.prop) {\n        return false;\n      }\n\n      const hasCallback = isFunction(callback);\n\n      if (!validateEnabled.value) {\n        callback == null ? void 0 : callback(false);\n        return false;\n      }\n\n      const rules = getFilteredRule(trigger);\n\n      if (rules.length === 0) {\n        callback == null ? void 0 : callback(true);\n        return true;\n      }\n\n      setValidationState(\"validating\");\n      return doValidate(rules).then(() => {\n        callback == null ? void 0 : callback(true);\n        return true;\n      }).catch(err => {\n        const {\n          fields\n        } = err;\n        callback == null ? void 0 : callback(false, fields);\n        return hasCallback ? false : Promise.reject(fields);\n      });\n    };\n\n    const clearValidate = () => {\n      setValidationState(\"\");\n      validateMessage.value = \"\";\n      isResettingField = false;\n    };\n\n    const resetField = async () => {\n      const model = formContext == null ? void 0 : formContext.model;\n      if (!model || !props.prop) return;\n      const computedValue = getProp(model, props.prop);\n      isResettingField = true;\n      computedValue.value = clone(initialValue);\n      await nextTick();\n      clearValidate();\n      isResettingField = false;\n    };\n\n    const addInputId = id => {\n      if (!inputIds.value.includes(id)) {\n        inputIds.value.push(id);\n      }\n    };\n\n    const removeInputId = id => {\n      inputIds.value = inputIds.value.filter(listId => listId !== id);\n    };\n\n    watch(() => props.error, val => {\n      validateMessage.value = val || \"\";\n      setValidationState(val ? \"error\" : \"\");\n    }, {\n      immediate: true\n    });\n    watch(() => props.validateStatus, val => setValidationState(val || \"\"));\n    const context = reactive({ ...toRefs(props),\n      $el: formItemRef,\n      size: _size,\n      validateState,\n      labelId,\n      inputIds,\n      isGroup,\n      hasLabel,\n      addInputId,\n      removeInputId,\n      resetField,\n      clearValidate,\n      validate\n    });\n    provide(formItemContextKey, context);\n    onMounted(() => {\n      if (props.prop) {\n        formContext == null ? void 0 : formContext.addField(context);\n        initialValue = clone(fieldValue.value);\n      }\n    });\n    onBeforeUnmount(() => {\n      formContext == null ? void 0 : formContext.removeField(context);\n    });\n    expose({\n      size: _size,\n      validateMessage,\n      validateState,\n      validate,\n      clearValidate,\n      resetField\n    });\n    return (_ctx, _cache) => {\n      var _a;\n\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"formItemRef\",\n        ref: formItemRef,\n        class: normalizeClass(unref(formItemClasses)),\n        role: unref(isGroup) ? \"group\" : void 0,\n        \"aria-labelledby\": unref(isGroup) ? unref(labelId) : void 0\n      }, [createVNode(unref(FormLabelWrap), {\n        \"is-auto-width\": unref(labelStyle).width === \"auto\",\n        \"update-all\": ((_a = unref(formContext)) == null ? void 0 : _a.labelWidth) === \"auto\"\n      }, {\n        default: withCtx(() => [unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? \"label\" : \"div\"), {\n          key: 0,\n          id: unref(labelId),\n          for: unref(labelFor),\n          class: normalizeClass(unref(ns).e(\"label\")),\n          style: normalizeStyle(unref(labelStyle))\n        }, {\n          default: withCtx(() => [renderSlot(_ctx.$slots, \"label\", {\n            label: unref(currentLabel)\n          }, () => [createTextVNode(toDisplayString(unref(currentLabel)), 1)])]),\n          _: 3\n        }, 8, [\"id\", \"for\", \"class\", \"style\"])) : createCommentVNode(\"v-if\", true)]),\n        _: 3\n      }, 8, [\"is-auto-width\", \"update-all\"]), createElementVNode(\"div\", {\n        class: normalizeClass(unref(ns).e(\"content\")),\n        style: normalizeStyle(unref(contentStyle))\n      }, [renderSlot(_ctx.$slots, \"default\"), createVNode(Transition, {\n        name: `${unref(ns).namespace.value}-zoom-in-top`\n      }, {\n        default: withCtx(() => [unref(shouldShowError) ? renderSlot(_ctx.$slots, \"error\", {\n          key: 0,\n          error: validateMessage.value\n        }, () => [createElementVNode(\"div\", {\n          class: normalizeClass(unref(validateClasses))\n        }, toDisplayString(validateMessage.value), 3)]) : createCommentVNode(\"v-if\", true)]),\n        _: 3\n      }, 8, [\"name\"])], 6)], 10, _hoisted_1);\n    };\n  }\n\n});\n\nvar FormItem = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue\"]]);\n\nexport { FormItem as default };","map":{"version":3,"mappings":"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","names":["name","slots","useSlots","inject","_size","useSize","formItem","useNamespace","useId","value","ref","refDebounced","formItemRef","initialValue","isResettingField","computed","formContext","labelWidth","addUnit","width","props","isNested","label","marginLeft","ns","b","m","validateState","is","isRequired","required","isBoolean","inlineMessage","e","_inlineMessage","prop","join","for","inputIds","length","labelFor","hasLabel","parentFormItemContext","model","getProp","rules","push","ensureArray","formRules","_rules","map","rule","i","filter","Object","keys","includes","requiredRules","validateEnabled","normalizedRules","trigger","Array","some","state","errors","fields","error","console","setValidationState","validateMessage","doValidate","firstFields","then","onValidationSucceeded","catch","err","onValidationFailed","callback","computedValue","clearValidate","id","listId","watch","val","immediate","$el","size","labelId","isGroup","addInputId","removeInputId","resetField","validate","provide","onMounted","onBeforeUnmount","expose"],"sources":["../../../../../../packages/components/form/src/form-item.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"formItemRef\"\n    :class=\"formItemClasses\"\n    :role=\"isGroup ? 'group' : undefined\"\n    :aria-labelledby=\"isGroup ? labelId : undefined\"\n  >\n    <form-label-wrap\n      :is-auto-width=\"labelStyle.width === 'auto'\"\n      :update-all=\"formContext?.labelWidth === 'auto'\"\n    >\n      <component\n        :is=\"labelFor ? 'label' : 'div'\"\n        v-if=\"hasLabel\"\n        :id=\"labelId\"\n        :for=\"labelFor\"\n        :class=\"ns.e('label')\"\n        :style=\"labelStyle\"\n      >\n        <slot name=\"label\" :label=\"currentLabel\">\n          {{ currentLabel }}\n        </slot>\n      </component>\n    </form-label-wrap>\n\n    <div :class=\"ns.e('content')\" :style=\"contentStyle\">\n      <slot />\n      <transition :name=\"`${ns.namespace.value}-zoom-in-top`\">\n        <slot v-if=\"shouldShowError\" name=\"error\" :error=\"validateMessage\">\n          <div :class=\"validateClasses\">\n            {{ validateMessage }}\n          </div>\n        </slot>\n      </transition>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  inject,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  toRefs,\n  useSlots,\n  watch,\n} from 'vue'\nimport AsyncValidator from 'async-validator'\nimport { clone } from 'lodash-unified'\nimport { refDebounced } from '@vueuse/core'\nimport {\n  addUnit,\n  ensureArray,\n  getProp,\n  isBoolean,\n  isFunction,\n  isString,\n} from '@element-plus/utils'\nimport { formContextKey, formItemContextKey } from '@element-plus/tokens'\nimport { useId, useNamespace, useSize } from '@element-plus/hooks'\nimport { formItemProps } from './form-item'\nimport FormLabelWrap from './form-label-wrap'\n\nimport type { CSSProperties } from 'vue'\nimport type { RuleItem } from 'async-validator'\nimport type {\n  FormItemContext,\n  FormItemRule,\n  FormValidateFailure,\n} from '@element-plus/tokens'\nimport type { Arrayable } from '@element-plus/utils'\nimport type { FormItemValidateState } from './form-item'\n\ndefineOptions({\n  name: 'ElFormItem',\n})\nconst props = defineProps(formItemProps)\nconst slots = useSlots()\n\nconst formContext = inject(formContextKey, undefined)\nconst parentFormItemContext = inject(formItemContextKey, undefined)\n\nconst _size = useSize(undefined, { formItem: false })\nconst ns = useNamespace('form-item')\n\nconst labelId = useId().value\nconst inputIds = ref<string[]>([])\n\nconst validateState = ref<FormItemValidateState>('')\nconst validateStateDebounced = refDebounced(validateState, 100)\nconst validateMessage = ref('')\nconst formItemRef = ref<HTMLDivElement>()\n// special inline value.\nlet initialValue: any = undefined\nlet isResettingField = false\n\nconst labelStyle = computed<CSSProperties>(() => {\n  if (formContext?.labelPosition === 'top') {\n    return {}\n  }\n\n  const labelWidth = addUnit(props.labelWidth || formContext?.labelWidth || '')\n  if (labelWidth) return { width: labelWidth }\n  return {}\n})\n\nconst contentStyle = computed<CSSProperties>(() => {\n  if (formContext?.labelPosition === 'top' || formContext?.inline) {\n    return {}\n  }\n  if (!props.label && !props.labelWidth && isNested) {\n    return {}\n  }\n  const labelWidth = addUnit(props.labelWidth || formContext?.labelWidth || '')\n  if (!props.label && !slots.label) {\n    return { marginLeft: labelWidth }\n  }\n  return {}\n})\n\nconst formItemClasses = computed(() => [\n  ns.b(),\n  ns.m(_size.value),\n  ns.is('error', validateState.value === 'error'),\n  ns.is('validating', validateState.value === 'validating'),\n  ns.is('success', validateState.value === 'success'),\n  ns.is('required', isRequired.value || props.required),\n  ns.is('no-asterisk', formContext?.hideRequiredAsterisk),\n  formContext?.requireAsteriskPosition === 'right'\n    ? 'asterisk-right'\n    : 'asterisk-left',\n  { [ns.m('feedback')]: formContext?.statusIcon },\n])\n\nconst _inlineMessage = computed(() =>\n  isBoolean(props.inlineMessage)\n    ? props.inlineMessage\n    : formContext?.inlineMessage || false\n)\n\nconst validateClasses = computed(() => [\n  ns.e('error'),\n  { [ns.em('error', 'inline')]: _inlineMessage.value },\n])\n\nconst propString = computed(() => {\n  if (!props.prop) return ''\n  return isString(props.prop) ? props.prop : props.prop.join('.')\n})\n\nconst hasLabel = computed<boolean>(() => {\n  return !!(props.label || slots.label)\n})\n\nconst labelFor = computed<string | undefined>(() => {\n  return props.for || inputIds.value.length === 1\n    ? inputIds.value[0]\n    : undefined\n})\n\nconst isGroup = computed<boolean>(() => {\n  return !labelFor.value && hasLabel.value\n})\n\nconst isNested = !!parentFormItemContext\n\nconst fieldValue = computed(() => {\n  const model = formContext?.model\n  if (!model || !props.prop) {\n    return\n  }\n  return getProp(model, props.prop).value\n})\n\nconst normalizedRules = computed(() => {\n  const { required } = props\n\n  const rules: FormItemRule[] = []\n\n  if (props.rules) {\n    rules.push(...ensureArray(props.rules))\n  }\n\n  const formRules = formContext?.rules\n  if (formRules && props.prop) {\n    const _rules = getProp<Arrayable<FormItemRule> | undefined>(\n      formRules,\n      props.prop\n    ).value\n    if (_rules) {\n      rules.push(...ensureArray(_rules))\n    }\n  }\n\n  if (required !== undefined) {\n    const requiredRules = rules\n      .map((rule, i) => [rule, i] as const)\n      .filter(([rule]) => Object.keys(rule).includes('required'))\n\n    if (requiredRules.length > 0) {\n      for (const [rule, i] of requiredRules) {\n        if (rule.required === required) continue\n        rules[i] = { ...rule, required }\n      }\n    } else {\n      rules.push({ required })\n    }\n  }\n\n  return rules\n})\n\nconst validateEnabled = computed(() => normalizedRules.value.length > 0)\n\nconst getFilteredRule = (trigger: string) => {\n  const rules = normalizedRules.value\n  return (\n    rules\n      .filter((rule) => {\n        if (!rule.trigger || !trigger) return true\n        if (Array.isArray(rule.trigger)) {\n          return rule.trigger.includes(trigger)\n        } else {\n          return rule.trigger === trigger\n        }\n      })\n      // exclude trigger\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      .map(({ trigger, ...rule }): RuleItem => rule)\n  )\n}\n\nconst isRequired = computed(() =>\n  normalizedRules.value.some((rule) => rule.required)\n)\n\nconst shouldShowError = computed(\n  () =>\n    validateStateDebounced.value === 'error' &&\n    props.showMessage &&\n    (formContext?.showMessage ?? true)\n)\n\nconst currentLabel = computed(\n  () => `${props.label || ''}${formContext?.labelSuffix || ''}`\n)\n\nconst setValidationState = (state: FormItemValidateState) => {\n  validateState.value = state\n}\n\nconst onValidationFailed = (error: FormValidateFailure) => {\n  const { errors, fields } = error\n  if (!errors || !fields) {\n    console.error(error)\n  }\n\n  setValidationState('error')\n  validateMessage.value = errors\n    ? errors?.[0]?.message ?? `${props.prop} is required`\n    : ''\n\n  formContext?.emit('validate', props.prop!, false, validateMessage.value)\n}\n\nconst onValidationSucceeded = () => {\n  setValidationState('success')\n  formContext?.emit('validate', props.prop!, true, '')\n}\n\nconst doValidate = async (rules: RuleItem[]): Promise<true> => {\n  const modelName = propString.value\n  const validator = new AsyncValidator({\n    [modelName]: rules,\n  })\n  return validator\n    .validate({ [modelName]: fieldValue.value }, { firstFields: true })\n    .then(() => {\n      onValidationSucceeded()\n      return true as const\n    })\n    .catch((err: FormValidateFailure) => {\n      onValidationFailed(err as FormValidateFailure)\n      return Promise.reject(err)\n    })\n}\n\nconst validate: FormItemContext['validate'] = async (trigger, callback) => {\n  // skip validation if its resetting\n  if (isResettingField || !props.prop) {\n    return false\n  }\n\n  const hasCallback = isFunction(callback)\n  if (!validateEnabled.value) {\n    callback?.(false)\n    return false\n  }\n\n  const rules = getFilteredRule(trigger)\n  if (rules.length === 0) {\n    callback?.(true)\n    return true\n  }\n\n  setValidationState('validating')\n\n  return doValidate(rules)\n    .then(() => {\n      callback?.(true)\n      return true as const\n    })\n    .catch((err: FormValidateFailure) => {\n      const { fields } = err\n      callback?.(false, fields)\n      return hasCallback ? false : Promise.reject(fields)\n    })\n}\n\nconst clearValidate: FormItemContext['clearValidate'] = () => {\n  setValidationState('')\n  validateMessage.value = ''\n  isResettingField = false\n}\n\nconst resetField: FormItemContext['resetField'] = async () => {\n  const model = formContext?.model\n  if (!model || !props.prop) return\n\n  const computedValue = getProp(model, props.prop)\n\n  // prevent validation from being triggered\n  isResettingField = true\n\n  computedValue.value = clone(initialValue)\n\n  await nextTick()\n  clearValidate()\n\n  isResettingField = false\n}\n\nconst addInputId: FormItemContext['addInputId'] = (id: string) => {\n  if (!inputIds.value.includes(id)) {\n    inputIds.value.push(id)\n  }\n}\n\nconst removeInputId: FormItemContext['removeInputId'] = (id: string) => {\n  inputIds.value = inputIds.value.filter((listId) => listId !== id)\n}\n\nwatch(\n  () => props.error,\n  (val) => {\n    validateMessage.value = val || ''\n    setValidationState(val ? 'error' : '')\n  },\n  { immediate: true }\n)\n\nwatch(\n  () => props.validateStatus,\n  (val) => setValidationState(val || '')\n)\n\nconst context: FormItemContext = reactive({\n  ...toRefs(props),\n  $el: formItemRef,\n  size: _size,\n  validateState,\n  labelId,\n  inputIds,\n  isGroup,\n  hasLabel,\n  addInputId,\n  removeInputId,\n  resetField,\n  clearValidate,\n  validate,\n})\n\nprovide(formItemContextKey, context)\n\nonMounted(() => {\n  if (props.prop) {\n    formContext?.addField(context)\n    initialValue = clone(fieldValue.value)\n  }\n})\n\nonBeforeUnmount(() => {\n  formContext?.removeField(context)\n})\n\ndefineExpose({\n  /** @description form item size */\n  size: _size,\n  /** @description validation message */\n  validateMessage,\n  /** @description validation state */\n  validateState,\n  /** @description validate form item */\n  validate,\n  /** @description clear validation status */\n  clearValidate,\n  /** @description reset field value */\n  resetField,\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}