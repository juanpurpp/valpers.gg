{"ast":null,"code":"import { ref, getCurrentInstance, inject, computed } from 'vue';\nimport '../../../../utils/index.mjs';\nimport '../../../../constants/index.mjs';\nimport '../../../../tokens/index.mjs';\nimport { checkboxGroupContextKey } from '../../../../tokens/checkbox.mjs';\nimport { isUndefined } from '../../../../utils/types.mjs';\nimport { isArray } from '@vue/shared';\nimport { UPDATE_MODEL_EVENT } from '../../../../constants/event.mjs';\n\nconst useCheckboxModel = props => {\n  const selfModel = ref(false);\n  const {\n    emit\n  } = getCurrentInstance();\n  const checkboxGroup = inject(checkboxGroupContextKey, void 0);\n  const isGroup = computed(() => isUndefined(checkboxGroup) === false);\n  const isLimitExceeded = ref(false);\n  const model = computed({\n    get() {\n      var _a, _b;\n\n      return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a.value : (_b = props.modelValue) != null ? _b : selfModel.value;\n    },\n\n    set(val) {\n      var _a, _b;\n\n      if (isGroup.value && isArray(val)) {\n        isLimitExceeded.value = ((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value);\n        isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));\n      } else {\n        emit(UPDATE_MODEL_EVENT, val);\n        selfModel.value = val;\n      }\n    }\n\n  });\n  return {\n    model,\n    isGroup,\n    isLimitExceeded\n  };\n};\n\nexport { useCheckboxModel };","map":{"version":3,"mappings":";;;;;;;;;AAIY,MAACA,gBAAgB,GAAIC,KAAD,IAAW;EACzC,MAAMC,SAAS,GAAGC,GAAG,CAAC,KAAD,CAArB;EACA,MAAM;IAAEC;EAAF,IAAWC,kBAAkB,EAAnC;EACA,MAAMC,aAAa,GAAGC,MAAM,CAACC,uBAAD,EAA0B,KAAK,CAA/B,CAA5B;EACA,MAAMC,OAAO,GAAGC,QAAQ,CAAC,MAAMC,WAAW,CAACL,aAAD,CAAX,KAA+B,KAAtC,CAAxB;EACA,MAAMM,eAAe,GAAGT,GAAG,CAAC,KAAD,CAA3B;EACA,MAAMU,KAAK,GAAGH,QAAQ,CAAC;IACrBI,GAAG,GAAG;MACJ,IAAIC,EAAJ,EAAQC,EAAR;;MACA,OAAOP,OAAO,CAACQ,KAAR,GAAgB,CAACF,EAAE,GAAGT,aAAa,IAAI,IAAjB,GAAwB,KAAK,CAA7B,GAAiCA,aAAa,CAACY,UAArD,KAAoE,IAApE,GAA2E,KAAK,CAAhF,GAAoFH,EAAE,CAACE,KAAvG,GAA+G,CAACD,EAAE,GAAGf,KAAK,CAACiB,UAAZ,KAA2B,IAA3B,GAAkCF,EAAlC,GAAuCd,SAAS,CAACe,KAAvK;IACD,CAJoB;;IAKrBE,GAAG,CAACC,GAAD,EAAM;MACP,IAAIL,EAAJ,EAAQC,EAAR;;MACA,IAAIP,OAAO,CAACQ,KAAR,IAAiBI,OAAO,CAACD,GAAD,CAA5B,EAAmC;QACjCR,eAAe,CAACK,KAAhB,GAAwB,CAAC,CAACF,EAAE,GAAGT,aAAa,IAAI,IAAjB,GAAwB,KAAK,CAA7B,GAAiCA,aAAa,CAACgB,GAArD,KAA6D,IAA7D,GAAoE,KAAK,CAAzE,GAA6EP,EAAE,CAACE,KAAjF,MAA4F,KAAK,CAAjG,IAAsGG,GAAG,CAACG,MAAJ,IAAcjB,aAAa,IAAI,IAAjB,GAAwB,KAAK,CAA7B,GAAiCA,aAAa,CAACgB,GAAd,CAAkBL,KAAjE,CAA9H;QACAL,eAAe,CAACK,KAAhB,KAA0B,KAA1B,KAAoC,CAACD,EAAE,GAAGV,aAAa,IAAI,IAAjB,GAAwB,KAAK,CAA7B,GAAiCA,aAAa,CAACkB,WAArD,KAAqE,IAArE,GAA4E,KAAK,CAAjF,GAAqFR,EAAE,CAACS,IAAH,CAAQnB,aAAR,EAAuBc,GAAvB,CAAzH;MACD,CAHD,MAGO;QACLhB,IAAI,CAACsB,kBAAD,EAAqBN,GAArB,CAAJ;QACAlB,SAAS,CAACe,KAAV,GAAkBG,GAAlB;MACD;IACF;;EAdoB,CAAD,CAAtB;EAgBA,OAAO;IACLP,KADK;IAELJ,OAFK;IAGLG;EAHK,CAAP;AAKF,CA3BY","names":["useCheckboxModel","props","selfModel","ref","emit","getCurrentInstance","checkboxGroup","inject","checkboxGroupContextKey","isGroup","computed","isUndefined","isLimitExceeded","model","get","_a","_b","value","modelValue","set","val","isArray","max","length","changeEvent","call","UPDATE_MODEL_EVENT"],"sources":["../../../../../../../packages/components/checkbox/src/composables/use-checkbox-model.ts"],"sourcesContent":["import { computed, getCurrentInstance, inject, ref } from 'vue'\nimport { isArray, isUndefined } from '@element-plus/utils'\nimport { UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport { checkboxGroupContextKey } from '@element-plus/tokens'\n\nimport type { CheckboxProps } from '../checkbox'\n\nexport const useCheckboxModel = (props: CheckboxProps) => {\n  const selfModel = ref<unknown>(false)\n  const { emit } = getCurrentInstance()!\n  const checkboxGroup = inject(checkboxGroupContextKey, undefined)\n  const isGroup = computed(() => isUndefined(checkboxGroup) === false)\n  const isLimitExceeded = ref(false)\n  const model = computed({\n    get() {\n      return isGroup.value\n        ? checkboxGroup?.modelValue?.value\n        : props.modelValue ?? selfModel.value\n    },\n\n    set(val: unknown) {\n      if (isGroup.value && isArray(val)) {\n        isLimitExceeded.value =\n          checkboxGroup?.max?.value !== undefined &&\n          val.length > checkboxGroup?.max.value\n        isLimitExceeded.value === false && checkboxGroup?.changeEvent?.(val)\n      } else {\n        emit(UPDATE_MODEL_EVENT, val)\n        selfModel.value = val\n      }\n    },\n  })\n\n  return {\n    model,\n    isGroup,\n    isLimitExceeded,\n  }\n}\n\nexport type CheckboxModel = ReturnType<typeof useCheckboxModel>\n"]},"metadata":{},"sourceType":"module"}